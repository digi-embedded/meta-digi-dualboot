From: Mike Engel <Mike.Engel@digi.com>
Date: Wed, 23 Jun 2021 15:00:02 +0200
Subject: [PATCH 2/2] firmware_update: add on the fly support

This commit adds on the fly support to the
Device Manager. That allows to update systems
without enough memory directly through the cloud.

Signed-off-by: Mike Engel <Mike.Engel@digi.com>
---
 library/src/cc_firmware_update.c | 356 ++++++++++++++++++++++++++++++---------
 1 file changed, 277 insertions(+), 79 deletions(-)

diff --git a/library/src/cc_firmware_update.c b/library/src/cc_firmware_update.c
index c1d4f23..ac2429b 100644
--- a/library/src/cc_firmware_update.c
+++ b/library/src/cc_firmware_update.c
@@ -22,6 +22,7 @@
 #include <errno.h>
 #include <miniunz/unzip.h>
 #include <pthread.h>
+#include <sys/reboot.h>
 #include <sys/stat.h>
 #include <sys/statvfs.h>
 #include <confuse.h>
@@ -31,6 +32,10 @@
 #include "cc_firmware_update.h"
 #include "cc_logging.h"
 
+/* SWUpdate support */
+#include <swupdate_status.h>
+#include <network_ipc.h>
+
 /*------------------------------------------------------------------------------
                              D E F I N I T I O N S
 ------------------------------------------------------------------------------*/
@@ -55,8 +60,9 @@
 #define WRITE_BUFFER_SIZE			128 * 1024 /* 128KB */
 
 #define LINE_BUFSIZE				255
-#define CMD_BUFSIZE				255
+#define CMD_BUFSIZE					255
 #define FW_UPDATE_CMD				"firmware-update-dual.sh"
+#define PRINTENV_ACTIVE_SYSTEM_CMD	"fw_printenv -n active_system"
 
 /*------------------------------------------------------------------------------
                  D A T A    T Y P E S    D E F I N I T I O N S
@@ -169,6 +175,85 @@ static FILE *fw_fp = NULL;
 static char *fw_downloaded_path = NULL;
 static pthread_t reboot_thread;
 
+static char buffer[WRITE_BUFFER_SIZE];
+int verbose = 1;
+static int end_status = EXIT_SUCCESS;
+static pthread_mutex_t mymutex;
+static pthread_cond_t cv_end = PTHREAD_COND_INITIALIZER;
+
+static int data_chunk = 0;
+static int chunk_size;
+static int last_chunk_size = 0;
+static bool update_successful = 0;
+static bool active_system_linux_a = 0;
+
+/* On the Fly call-back functions */
+/*
+ * this is the callback to get a new chunk of the
+ * image.
+ * It is called by a thread generated by the library and
+ * can block.
+ */
+static int readimage(char **p, int *size) {
+
+	while (data_chunk == 0)
+		usleep(1000);
+
+	*p = buffer;
+	*size = chunk_size;
+	if (chunk_size >= last_chunk_size)
+		data_chunk = 0;
+	last_chunk_size = chunk_size;
+	chunk_size = 0;
+	return last_chunk_size;
+}
+
+/*
+ * This is called by the library to inform
+ * about the current status of the upgrade
+ */
+static int printstatus(ipc_message *msg)
+{
+	if (verbose)
+		log_fw_info("Status: %d message: %s\n",
+			msg->data.status.current,
+			strlen(msg->data.status.desc) > 0 ? msg->data.status.desc : "");
+
+	return 0;
+}
+
+/*
+ * this is called at the end reporting the status
+ * of the upgrade and running any post-update actions
+ * if successful
+ */
+static int end(RECOVERY_STATUS status)
+{
+	bool run_postupdate = false;
+
+	end_status = (status == SUCCESS) ? EXIT_SUCCESS : EXIT_FAILURE;
+
+	log_fw_info("Swupdate %s\n",
+		status == FAILURE ? "*failed* !" :
+			"was successful !");
+
+	if (status == SUCCESS && run_postupdate) {
+		log_fw_info("Executing post-update actions. %s\n", __func__);
+		ipc_message msg;
+		if (ipc_postupdate(&msg) != 0)
+			log_fw_info("Running post-update failed! %s\n", __func__);
+	}
+
+	pthread_mutex_lock(&mymutex);
+	pthread_cond_signal(&cv_end);
+	pthread_mutex_unlock(&mymutex);
+
+	if (status == SUCCESS)
+		update_successful = 1;
+
+	return 0;
+}
+
 /*------------------------------------------------------------------------------
                      F U N C T I O N  D E F I N I T I O N S
 ------------------------------------------------------------------------------*/
@@ -189,6 +274,8 @@ ccapi_fw_request_error_t app_fw_request_cb(unsigned int const target,
 		char const *const filename, size_t const total_size) {
 	ccapi_fw_request_error_t error = CCAPI_FW_REQUEST_ERROR_NONE;
 	size_t available_space;
+	int retval;
+	static struct swupdate_request req;
 
 	log_fw_info("Firmware download requested (target '%d')", target);
 
@@ -197,31 +284,91 @@ ccapi_fw_request_error_t app_fw_request_cb(unsigned int const target,
 		return CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
 	}
 
-	fw_downloaded_path = concatenate_path(cc_cfg->fw_download_path, filename);
-	if (fw_downloaded_path == NULL) {
-		log_fw_error(
-				"Cannot allocate memory for '%s' firmware file (target '%d')",
-				filename, target);
-		return CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
-	}
+	if (cc_cfg->on_the_fly) {
+		char cmd[CMD_BUFSIZE] = {0};
+		char line[LINE_BUFSIZE] = {0};
+		char proc_path[256] = {0};
+		struct stat stats;
+		int string_len = 7;
+		FILE *fp;
 
-	available_space = get_available_space(cc_cfg->fw_download_path);
-	if (available_space == 0) {
-		log_fw_error("Unable to get available space (target '%d')", target);
-		error = CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
-		goto done;
-	}
-	if (available_space < total_size) {
-		log_fw_error("Not enough space to download '%s' firmware file (target '%d')", filename, target);
-		error = CCAPI_FW_REQUEST_ERROR_DOWNLOAD_INVALID_SIZE;
-		goto done;
-	}
+		log_fw_debug("Firmware download streaming requested (target '%d')", target);
+		/* Start swupdate prcess */
+		pthread_mutex_init(&mymutex, NULL);
 
-	fw_fp = fopen(fw_downloaded_path, "wb+");
-	if (fw_fp == NULL) {
-		log_fw_error("Unable to create '%s' file (target '%d')", filename, target);
-		error = CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
-		goto done;
+		/* May be set non-zero by end() function on failure */
+		end_status = EXIT_SUCCESS;
+
+		/* Prepare request structure */
+		swupdate_prepare_req(&req);
+
+		sprintf(cmd, "%s", PRINTENV_ACTIVE_SYSTEM_CMD);
+
+		/* Read u-boot enviroment to detect active system */
+		fp = popen(cmd, "r");
+		if (fp == NULL){
+			log_fw_error("Couldn't execute cmd %s", cmd);
+			retval = -1;
+		} else {
+			/* Read script output till finished */
+			if (fgets(line, LINE_BUFSIZE, fp) == NULL) {
+				log_fw_debug("swupdate: %s", line);
+			}
+			/* close the process */
+			pclose(fp);
+			/* Detect storage media */
+			sprintf(proc_path, "%s", "/proc/mtd");
+			stat(proc_path, &stats);
+			/* On eMMC devices the size will be zero */
+			if (stats.st_size != 0) {
+				strncpy(req.software_set, "mtd" , sizeof(req.software_set) - 1);
+			} else {
+				strncpy(req.software_set, "mmc" , sizeof(req.software_set) - 1);
+			}
+
+			/* detect active system */
+			if (!strncmp(line, "linux_a", string_len)) {
+				strncpy(req.running_mode, "secondary" , sizeof(req.running_mode) -1);
+				active_system_linux_a = 1;
+			} else {
+				strncpy(req.running_mode, "primary" , sizeof(req.running_mode) - 1);
+				active_system_linux_a = 0;
+			}
+			retval = swupdate_async_start(readimage, printstatus, end, &req, sizeof(req));
+		}
+
+		/* return if we've hit an error scenario */
+		if (retval < 0) {
+			fprintf(stderr, "swupdate_async_start returns %d\n", retval);
+			pthread_mutex_unlock(&mymutex);
+			return CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
+		}
+	} else {
+		fw_downloaded_path = concatenate_path(cc_cfg->fw_download_path, filename);
+		if (fw_downloaded_path == NULL) {
+			log_fw_error("Cannot allocate memory for '%s' firmware file (target '%d')",
+						  filename, target);
+			return CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
+		}
+
+		available_space = get_available_space(cc_cfg->fw_download_path);
+		if (available_space == 0) {
+			log_fw_error("Unable to get available space (target '%d')", target);
+			error = CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
+			goto done;
+		}
+		if (available_space < total_size) {
+			log_fw_error("Not enough space to download '%s' firmware file (target '%d')", filename, target);
+			error = CCAPI_FW_REQUEST_ERROR_DOWNLOAD_INVALID_SIZE;
+			goto done;
+		}
+
+		fw_fp = fopen(fw_downloaded_path, "wb+");
+		if (fw_fp == NULL) {
+			log_fw_error("Unable to create '%s' file (target '%d')", filename, target);
+			error = CCAPI_FW_REQUEST_ERROR_ENCOUNTERED_ERROR;
+			goto done;
+		}
 	}
 
 done:
@@ -250,57 +397,83 @@ done:
 ccapi_fw_data_error_t app_fw_data_cb(unsigned int const target, uint32_t offset,
 		void const *const data, size_t size, ccapi_bool_t last_chunk) {
 	ccapi_fw_data_error_t error = CCAPI_FW_DATA_ERROR_NONE;
-	int retval;
+	int retval, loops = 0;
 
 	log_fw_debug("Received chunk: target=%d offset=0x%x length=%zu last_chunk=%d", target, offset, size, last_chunk);
 
-	retval = fwrite(data, size, 1, fw_fp);
-	if (retval != 1) {
-		log_fw_error("%s", "Error writing to firmware file");
-		return CCAPI_FW_DATA_ERROR_INVALID_DATA;
-	}
-
-	if (last_chunk) {
-		if (fw_fp != NULL) {
-			int fd = fileno(fw_fp);
-			if (fsync(fd) != 0 || fclose(fw_fp) != 0) {
-				log_fw_error("Unable to close firmware file (errno %d: %s)", errno, strerror(errno));
-				return CCAPI_FW_DATA_ERROR_INVALID_DATA;
+	if (cc_cfg->on_the_fly) {
+		log_fw_debug("Get data package from Remote Manager %d", target);
+		chunk_size = size;
+		memcpy (buffer, data, chunk_size);
+		data_chunk = 1;
+
+		if (last_chunk) {
+			log_fw_debug("Firmware download completed for target '%d'", target);
+			/* End called, unlock and exit */
+			pthread_mutex_lock(&mymutex);
+			pthread_cond_wait(&cv_end, &mymutex);
+			pthread_mutex_unlock(&mymutex);
+
+			/* Because of the async update write we need to wait till last package has
+			 * been written.
+			 */
+			while (update_successful == 0 && loops < 100) {
+				usleep(10000);
+				log_fw_debug("Digi: wait for download and update to finish %d\n", update_successful);
+				loops++;
 			}
+			if (loops >= 100)
+				error = CCAPI_FW_DATA_ERROR_INVALID_DATA;
+		}
+	} else {
+		retval = fwrite(data, size, 1, fw_fp);
+		if (retval != 1) {
+			log_fw_error("%s", "Error writing to firmware file");
+			return CCAPI_FW_DATA_ERROR_INVALID_DATA;
 		}
-		log_fw_info("Firmware download completed for target '%d'", target);
-
-		log_fw_info("Starting firmware update process (target '%d')", target);
 
-		switch(target) {
-		/* Target for *.swu files. */
-		case 0: {
-			if (cc_cfg->dualboot == CCAPI_FALSE) {
-				if (update_firmware(fw_downloaded_path)) {
+		if (last_chunk) {
+			if (fw_fp != NULL) {
+				int fd = fileno(fw_fp);
+				if (fsync(fd) != 0 || fclose(fw_fp) != 0) {
+					log_fw_error("Unable to close firmware file (errno %d: %s)", errno, strerror(errno));
+					return CCAPI_FW_DATA_ERROR_INVALID_DATA;
+				}
+			}
+			log_fw_info("Firmware download completed for target '%d'", target);
+
+			log_fw_info("Starting firmware update process (target '%d')", target);
+
+			switch(target) {
+			/* Target for *.swu files. */
+			case 0: {
+				if (cc_cfg->dualboot == CCAPI_FALSE) {
+					if (update_firmware(fw_downloaded_path)) {
+						log_fw_error(
+								"Error updating firmware using package '%s' for target '%d'",
+								fw_downloaded_path, target);
+						error = CCAPI_FW_DATA_ERROR_INVALID_DATA;
+					}
+				}
+				break;
+			}
+			/* Target for manifest.txt files. */
+			case 1: {
+				if (update_manifest_firmware(fw_downloaded_path, target) != 0) {
 					log_fw_error(
 							"Error updating firmware using package '%s' for target '%d'",
 							fw_downloaded_path, target);
 					error = CCAPI_FW_DATA_ERROR_INVALID_DATA;
 				}
+				break;
 			}
-			break;
-		}
-		/* Target for manifest.txt files. */
-		case 1: {
-			if (update_manifest_firmware(fw_downloaded_path, target) != 0) {
-				log_fw_error(
-						"Error updating firmware using package '%s' for target '%d'",
-						fw_downloaded_path, target);
+			default:
 				error = CCAPI_FW_DATA_ERROR_INVALID_DATA;
 			}
-			break;
-		}
-		default:
-			error = CCAPI_FW_DATA_ERROR_INVALID_DATA;
-		}
 
-		if (cc_cfg->dualboot == CCAPI_FALSE)
-			free(fw_downloaded_path);
+			if (cc_cfg->dualboot == CCAPI_FALSE)
+				free(fw_downloaded_path);
+		}
 	}
 
 	return error;
@@ -347,34 +520,49 @@ void app_fw_reset_cb(unsigned int const target, ccapi_bool_t *system_reset, ccap
 {
 	unsigned int *reboot_timeout = NULL;
 	int error = 0;
+	char cmd[CMD_BUFSIZE] = {0};
+	char line[LINE_BUFSIZE] = {0};
+	FILE *fp;
 
 	UNUSED_PARAMETER(target);
 	UNUSED_PARAMETER(version);
 
 	*system_reset = CCAPI_FALSE;
 
-	if (cc_cfg->dualboot) {
-		char cmd[CMD_BUFSIZE] = {0};
-		char line[LINE_BUFSIZE] = {0};
-		FILE *fp;
-
-		log_fw_debug("We will start the %s script at path %s", FW_UPDATE_CMD, fw_downloaded_path);
-		sprintf(cmd, "%s %s", FW_UPDATE_CMD, fw_downloaded_path);
-		/* Free buffer */
-		free(fw_downloaded_path);
-		/* Open process to execute update command */
+	if (cc_cfg->on_the_fly){
+		log_fw_debug("On the fly update finished. Now we will reboot the system %d", update_successful);
+		if ( update_successful == 0) {
+			log_fw_error("On the fly update failed. %d", update_successful);
+			return;
+		}
+		/* Swap the active system partition */
+		sprintf(cmd, "%s", "on-the-fly-swap-partition.sh");
 		fp = popen(cmd, "r");
 		if (fp == NULL){
-			log_fw_error("Couldn't execute dualboot installation cmd %s", cmd);
+			log_fw_error("Couldn't execute cmd %s", cmd);
 		} else {
-			/* Read script output till finished */
-			while (fgets(line, LINE_BUFSIZE, fp) != NULL) {
-				log_fw_debug("swupdate: %s", line);
-			}
-			/* close the process */
 			pclose(fp);
 		}
-		return;
+	} else {
+		if (cc_cfg->dualboot) {
+			log_fw_debug("We will start the %s script at path %s", FW_UPDATE_CMD, fw_downloaded_path);
+			sprintf(cmd, "%s %s", FW_UPDATE_CMD, fw_downloaded_path);
+			/* Free buffer */
+			free(fw_downloaded_path);
+			/* Open process to execute update command */
+			fp = popen(cmd, "r");
+			if (fp == NULL){
+				log_fw_error("Couldn't execute dualboot installation cmd %s", cmd);
+			} else {
+				/* Read script output till finished */
+				while (fgets(line, LINE_BUFSIZE, fp) != NULL) {
+					log_fw_debug("swupdate: %s", line);
+				}
+				/* close the process */
+				pclose(fp);
+			}
+			return;
+		}
 	}
 
 	reboot_timeout = malloc(sizeof (unsigned int));
@@ -386,8 +574,18 @@ void app_fw_reset_cb(unsigned int const target, ccapi_bool_t *system_reset, ccap
 
 	log_fw_info("Rebooting in %d seconds", *reboot_timeout);
 
-	error = pthread_create(&reboot_thread, NULL, reboot_threaded,
-			(void *) reboot_timeout);
+	if (cc_cfg->on_the_fly) {
+		/* reboot system */
+		sync();
+
+		fflush(stdout);
+		sleep(REBOOT_TIMEOUT);
+
+		reboot(RB_AUTOBOOT);
+	} else {
+		error = pthread_create(&reboot_thread, NULL, reboot_threaded,
+				(void *) reboot_timeout);
+	}
 
 error:
 
-- 
